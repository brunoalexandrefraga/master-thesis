---
title: Integer-N PFD/CP-based PLL - System-Level simulation
subtitle: Laboratory 01 - Week 01-09
author:
  - name: Bruno Alexandre Fraga
    email: bruno.fraga@posgrad.ufsc.br
    affiliations: 
        - id: some-tech
          name: Universidade Federal de Santa Catarina
          department: Departamento de Engenharia Elétrica e Eletrônica
          address: R. Delfino Conti
          city: Florianópolis
          state: Santa Catarina
          postal-code: 88040-370
abstract: |
    Este trabalho apresenta duas simulações para um Integer-N PFD/CP-based PLL a nível de sistema. Uma simulação é no domínio do tempo e a outra no domínio da fase. Foram estabelecidas restrições para a operação e são apresentados os passos até a concepção dos sistemas para a simulação. Por fim, os resultados são analisados quanto ao tempo de resposta e comparados ao que foi previsto com base na teoria.
keywords: 
  - Phase-locked loop
  - Sistema de controle
  - PLL Integer-N
date: last-modified
bibliography:
  - bibliography.bib
  - zoterobibliography.bib
format:
  elsevier-pdf:
    include-in-header:
      - text: |
          \usepackage{steinmetz}
          \usepackage[a4paper, margin=1in]{geometry}
          \usepackage{graphicx} % Required for inserting images
          \usepackage{circuitikz}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{amsthm}
          \usepackage{comment}
          \usepackage{tikz}
          \usetikzlibrary{shapes,arrows}
          \usetikzlibrary{shapes,arrows,positioning,calc}


          \newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}
    keep-tex: true
    journal:
      name: Programa de Pós-Graduação em Engenharia Elétrica
      formatting: preprint
      # model: 3p # Don't set a model with preprint
      cite-style: number
---

```{python}
#| echo: false

from IPython.display import display, Markdown

def format(value, decimals=2):
    abs_value = abs(value)
    fmt = f".{decimals}f"
    
    if abs_value >= 1e9:
        result = f"{value / 1e9:{fmt}}\\,\\text{{G}}"
    elif abs_value >= 1e6:
        result = f"{value / 1e6:{fmt}}\\,\\text{{M}}"
    elif abs_value >= 1e3:
        result = f"{value / 1e3:{fmt}}\\,\\text{{k}}"
    elif abs_value >= 1:
        result = f"{value * 1e0:{fmt}}\\,"
    elif abs_value >= 1e-3:
        result = f"{value * 1e3:{fmt}}\\,\\text{{m}}"
    elif abs_value >= 1e-6:
        result = f"{value * 1e6:{fmt}}\\,\\mu"
    elif abs_value >= 1e-9:
        result = f"{value * 1e9:{fmt}}\\,\\text{{n}}"
    elif abs_value >= 1e-12:
        result = f"{value * 1e12:{fmt}}\\,\\text{{p}}"
    elif abs_value >= 1e-15:
        result = f"{value * 1e15:{fmt}}\\,\\text{{f}}"
    else:
        result = f"{value:.0e}\\,"

    return Markdown(f"${result}$")

```

```{python}
#| echo: false
import math
from IPython.display import display, Markdown

def format_with_pi_latex(value):
    pi_multiple = value / math.pi
    abs_pi_multiple = abs(pi_multiple)

    if abs_pi_multiple >= 1e9:
        result = f"{pi_multiple / 1e9:.2f}\\pi\\,\\text{{G}}"
    elif abs_pi_multiple >= 1e6:
        result = f"{pi_multiple / 1e6:.2f}\\pi\\,\\text{{M}}"
    elif abs_pi_multiple >= 1e3:
        result = f"{pi_multiple / 1e3:.2f}\\pi\\,\\text{{k}}"
    elif abs_pi_multiple >= 1:
        result = f"{pi_multiple:.2f}\\pi"
    elif abs_pi_multiple >= 1e-3:
        result = f"{pi_multiple * 1e3:.2f}\\pi\\,\\text{{m}}"
    elif abs_pi_multiple >= 1e-6:
        result = f"{pi_multiple * 1e6:.2f}\\pi\\,\\mu"
    elif abs_pi_multiple >= 1e-9:
        result = f"{pi_multiple * 1e9:.2f}\\pi\\,\\text{{n}}"
    elif abs_pi_multiple >= 1e-12:
        result = f"{pi_multiple * 1e12:.2f}\\pi\\,\\text{{p}}"
    elif abs_pi_multiple >= 1e-15:
        result = f"{pi_multiple * 1e15:.2f}\\pi\\,\\text{{f}}"
    else:
        result = f"{pi_multiple:.0e}\\pi"

    return Markdown(f"${result}$")

# Exemplo de uso:

```

```{python}
#| echo: false


def format_e(value):
    return f"{value:.0e}"
```

```{python}
#| echo: false

import math

f0=3.7e9
f = 4.3e9
tunning_range = f-f0
step=1e6
fref = 1e6
I_CP=2*math.pi*100e-6
V_sup=3
f_3dB=150e3
omega_3dB=f_3dB*2*math.pi

Kvco=tunning_range/V_sup
Kvco_ang=Kvco*2*math.pi

f_30M=30e6
f_300M=300e6

Ktheta=I_CP/(2*math.pi)

fvco=4e9
N = fvco/fref
```

# Introduction
A `{python} format(f0)`Hz–`{python} format(f)`Hz synthesizer with a step size of `{python} format(step)`Hz is required, as the PLL is an Integer-N, $f_\text{ref}=$ `{python} format(fref)`Hz, a charge pump with `{python} format(I_CP)`A output current, and a VCO (operating from a `{python} format(V_sup)`V supply) are available. Designing a integer-N synthesizer with a loop bandwidth of `{python} format(f_3dB)`Hz using these components.

## VCO

For the VCO, if the system is fed with a `{python} format(V_sup)`V supply and the tuning range is `{python} format(tunning_range)`Hz, so the VCO constant can be $K_\text{VCO}=$ `{python} format(Kvco)`Hz/V. And initially the nominal frequency is arbitrary selected as $f_\text{VCO}=$ `{python} format(fvco)`Hz. With that nominal frequency, the division ratio will be $N=$ `{python} N`.

## Charge pump

In addition, since the charge pump current is known, the charge pump constant can be determined as $K_\theta=$ `{python} format(Ktheta)`A/rad.

## Loop filter

```{python}
#| echo: false

import math

fref_f3dB=fref/f_3dB
```

As the ration of reference frequency and bandwidth is $f_\text{ref}/f_{3\text{dB}}=$ `{python} round(fref_f3dB, 0)`, i.e. $f_\text{ref}\gg f_{3\text{dB}}$, the continuous-time analysis can be used.

This section is responsible to present the design of the loop filter. First of all, it's needed to determine the value of natural frequency,

$$
\omega_n=\frac{\omega_{3\text{dB}}}{\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}}
$$

```{python}
#| echo: false
import math

zeta = 0.707

omega_n=omega_3dB/math.sqrt(1+2*zeta**2+math.sqrt(4*zeta**4+4*zeta**2+2))
f_n=omega_n/(2*math.pi)
```

Choosing a damping constant, $\zeta=$ `{python} zeta`, $f_n=$ `{python} format(f_n)`Hz.

The first capacitor, $C_1$, can be calculated as

$$
C_1=\frac{IK_\text{VCO}}{2\pi\cdot N\omega_n^2}
$$

```{python}
#| echo: false
import math

C_1=I_CP*Kvco_ang/(2*math.pi*N*omega_n**2)

```

So this capacitor has a value of, $C_1=$ `{python} format(C_1)`F.

The first resistor (and the single one) used in the second-order loop filter will can be obtained as follows,

$$
R_1=2\zeta\sqrt{\frac{2\pi\cdot N}{IK_\text{VCO}C_1}}
$$

```{python}
#| echo: false

import math 

R_1=2*zeta*math.sqrt((2*math.pi*N)/(I_CP*Kvco_ang*C_1))
C_2=C_1/10
```

The value of that first resistor is $R_1=$ `{python} format(R_1)`$\Omega$. And the second capacitor, $C_2$, is obtained as one-tenth of $C_1$, getting the value of $C_2=$ `{python} format(C_2)`F.

# Phase noise

The intention of this report is to present analysis of phase noise in a integer-N PLL already designed. 

```{python}
#| echo: false
import math

pn_vco=-120
offset_vco=1e6
offset_vco_ang =1e6*2*math.pi
noise_floor = -130
I_noise_CP=10e-12
```

First of all, the VCO phase noise is supposed as being The VCO has a phase noise of $PN_\text{VCO}=$ `{python} pn_vco` dBc/Hz at a $\Delta f=$ `{python} format(offset_vco)`Hz offset (it bottoms out at $PN_{\text{VCO}_0}=$ `{python} noise_floor` dBc/Hz), and the charge pump puts out a noise current of $i_{n_\text{CP}}=$ `{python} format(I_noise_CP)`A/$\sqrt{\text{Hz}}$. Ignoring  PFD, divider, and reference noise sources.

Assuming that the VCO follows the 20 dB/dec rule it's possible to come up with a linear expression for the phase noise of the VCO based on

$$
\varphi_\text{VCO}^2\left(\Delta\omega\right)=\frac{C}{\Delta\omega^2}+D
$$

So it's needed to get the parameters $C$ and $D$. Since the above equation must be linear at the logaritmic view, the parameter $C$ can be obtained as follows

$$
C=10^\frac{PN_\text{VCO}}{10}\cdot\Delta\omega^2
$$

```{python}
#| echo: false
import math

C_param = 10**(pn_vco/10)*offset_vco_ang**2
```

Thus $C=$ `{python} round(C_param, 1)` $\text{rad}^4/\text{Hz}^2$. The parameter $D$, for its time, can be calculated as

$$
D=10^\frac{PN_{\text{VCO}_0}}{10}
$$

```{python}
#| echo: false

import math

D_param=10**(noise_floor/10)
```

And it results in $D=$ `{python} format_e(D_param)` $\text{rad}^2/\text{Hz}$. Thus the equation previously presented becomes

```{python}
#| echo: false 

import math
from IPython.display import display, Markdown


eq = f"\\varphi_\\text{{VCO}}^2\\left(\\Delta\\omega\\right)=\\frac{{{round(C_param, 1)}}}{{\\Delta\\omega^2}}+{format_e(D_param)}"
display(Markdown(f"$$ {eq} $$"))
```

The output noise current from the charge pump can be input-referred by dividing by $K_\theta$

$$
\varphi_\text{CP}=\frac{i_{n_\text{CP}}}{K_\theta}
$$

```{python}
#| echo: false
import math

phi_CP = I_noise_CP/Ktheta

```

Using the above equation it results in $\varphi_\text{CP}=$ `{python} format(phi_CP)`$\text{rad}/\sqrt{\text{Hz}}$.

To calculate the noise provided by the second-order loop filter, it's needed to analyse that

The noise voltage develops a current flowing through the series combination of $C_1$ , $C_2$ , and $R$,

$$
\begin{split}
i_{n_\text{LPF}}&=\frac{v_n}{R+\frac{1}{C_1s}+\frac{1}{C_2s}}=\frac{1}{R}\cdot\frac{v_ns}{s+\frac{C_1+C_2}{C_1C_2R}}\implies\\
&\approx\frac{1}{R}\cdot\frac{v_ns}{s+\frac{1}{C_2R}}
\end{split}
$$

Similarly, the analysis can be done for the voltage, i.e.,

$$
v_{n_\text{LPF}}=\frac{i_ns}{s+\frac{1}{C_2R}}
$$

As the current noise is provided by the resistor, $i_n=\sqrt{4kT/R}$. To analyze the system noise properly, it's needed to refer the noise to the input,

$$
\begin{split}
\varphi_\text{LPF}&=\frac{v_{n_\text{LPF}}}{K_\theta}\implies\\
&=\frac{1}{K_\theta}\cdot\left|\frac{\sqrt{\frac{4kT}{R}}s}{s+\frac{1}{C_2R}}\right|\implies\\
\end{split}
$$

Now, it's possible to get the transfer function of the noise due to the PFD, charge pump, divider and loop filter (everything referred to the input) as follows

$$
\begin{split}
\frac{\varphi_\text{no}(s)}{\varphi_\text{nI}(s)}&=\frac{\frac{F(s)K_\text{VCO}K_\theta}{Ns}}{1+\frac{F(s)K_\text{VCO}K_\theta}{Ns}}\cdot N\cdot\frac{s}{s}\implies\\
&=\frac{F(s)K_\text{VCO}K_\theta}{s+\frac{F(s)K_\text{VCO}K_\theta}{N}}
\end{split}
$$
as the PSD output noise, $\varphi_\text{no}$, is obtained before the divider, the function could be multiplied by $N$ (i.e. divided by $N^{-1}$).

For a PLL with a second-order loop filter,

$$
\begin{split}
\frac{\varphi_\text{no}(s)}{\varphi_\text{nI}(s)}&=\frac{\frac{IK_\text{VCO}}{2\pi\cdot C_1}\left(1+RC_1s\right)}{s^2+\frac{IK_\text{VCO}}{2\pi\cdot N}Rs+\frac{IK_\text{VCO}}{2\pi\cdot NC_1}}
\end{split}
$$

Substituting the values, it results in

```{python}
#| echo: false
import sympy as sp
from IPython.display import display, Markdown

# Variáveis simbólicas
s = sp.symbols('s')
I_sym, Kvco_sym, R1_sym, C1_sym, N_sym = sp.symbols('I Kvco R1 C1 N')

# Constante K = (I * Kvco) / (2π)
K_sym = (I_sym * Kvco_sym) / (2 * sp.pi)

# Numerador e denominador da função de transferência
num = K_sym / C1_sym * (1 + R1_sym * C1_sym * s)
den = s**2 + (K_sym * R1_sym / N_sym) * s + K_sym / (N_sym * C1_sym)

# Função de transferência
H_s = num / den

# Substitui os valores
H_subs = H_s.subs({I_sym: I_CP, Kvco_sym: Kvco_ang, C1_sym: C_1, R1_sym: R_1, N_sym: N}).evalf(4)

# Converte para LaTeX
latex_str = sp.latex(H_subs)
#latex_str_eq = sp.latex(H_s)

display(Markdown(f"$$\\frac{{\\varphi_\\text{{no}}(s)}}{{\\varphi_\\text{{nI}}(s)}} = {latex_str}$$ {{#eq-filter-transfer-function}}"))
#display(Markdown(f"$$\\frac{{\\varphi_\\text{{no}}(s)}}{{\\varphi_\\text{{nI}}(s)}} = {latex_str_eq}$$ {{#eq-filter-transfer-function}}"))
```











# References {-}
