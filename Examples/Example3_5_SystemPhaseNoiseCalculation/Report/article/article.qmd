---
title: Integer-N PFD/CP-based PLL - System-Level simulation
subtitle: Laboratory 01 - Week 01-09
author:
  - name: Bruno Alexandre Fraga
    email: bruno.fraga@posgrad.ufsc.br
    affiliations: 
        - id: some-tech
          name: Universidade Federal de Santa Catarina
          department: Departamento de Engenharia Elétrica e Eletrônica
          address: R. Delfino Conti
          city: Florianópolis
          state: Santa Catarina
          postal-code: 88040-370
abstract: |
    Este trabalho apresenta duas simulações para um Integer-N PFD/CP-based PLL a nível de sistema. Uma simulação é no domínio do tempo e a outra no domínio da fase. Foram estabelecidas restrições para a operação e são apresentados os passos até a concepção dos sistemas para a simulação. Por fim, os resultados são analisados quanto ao tempo de resposta e comparados ao que foi previsto com base na teoria.
keywords: 
  - Phase-locked loop
  - Sistema de controle
  - PLL Integer-N
date: last-modified
bibliography:
  - bibliography.bib
  - zoterobibliography.bib
format:
  elsevier-pdf:
    include-in-header:
      - text: |
          \usepackage{steinmetz}
          \usepackage[a4paper, margin=1in]{geometry}
          \usepackage{graphicx} % Required for inserting images
          \usepackage{circuitikz}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{amsthm}
          \usepackage{comment}
          \usepackage{tikz}
          \usetikzlibrary{shapes,arrows}
          \usetikzlibrary{shapes,arrows,positioning,calc}


          \newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}
    keep-tex: true
    journal:
      name: Programa de Pós-Graduação em Engenharia Elétrica
      formatting: preprint
      # model: 3p # Don't set a model with preprint
      cite-style: number
---

```{python}
#| echo: false

from IPython.display import display, Markdown

def format(value):
    abs_value = abs(value)
    if abs_value >= 1e9:
        result = f"{value / 1e9:.2f}\\,\\text{{G}}"
    elif abs_value >= 1e6:
        result = f"{value / 1e6:.2f}\\,\\text{{M}}"
    elif abs_value >= 1e3:
        result = f"{value / 1e3:.2f}\\,\\text{{k}}"
    elif abs_value >= 1:
        result = f"{value * 1e0:.2f}\\,"
    elif abs_value >= 1e-3:
        result = f"{value * 1e3:.2f}\\,\\text{{m}}"
    elif abs_value >= 1e-6:
        result = f"{value * 1e6:.2f}\\,\\mu"
    elif abs_value >= 1e-9:
        result = f"{value * 1e9:.2f}\\,\\text{{n}}"
    elif abs_value >= 1e-12:
        result = f"{value * 1e12:.2f}\\,\\text{{p}}"
    elif abs_value >= 1e-15:
        result = f"{value * 1e15:.2f}\\,\\text{{f}}"
    else:
        result = f"{value:.0e}\\,"

    return Markdown(f"${result}$")
```

```{python}
#| echo: false
import math
from IPython.display import display, Markdown

def format_with_pi_latex(value):
    pi_multiple = value / math.pi
    abs_pi_multiple = abs(pi_multiple)

    if abs_pi_multiple >= 1e9:
        result = f"{pi_multiple / 1e9:.2f}\\pi\\,\\text{{G}}"
    elif abs_pi_multiple >= 1e6:
        result = f"{pi_multiple / 1e6:.2f}\\pi\\,\\text{{M}}"
    elif abs_pi_multiple >= 1e3:
        result = f"{pi_multiple / 1e3:.2f}\\pi\\,\\text{{k}}"
    elif abs_pi_multiple >= 1:
        result = f"{pi_multiple:.2f}\\pi"
    elif abs_pi_multiple >= 1e-3:
        result = f"{pi_multiple * 1e3:.2f}\\pi\\,\\text{{m}}"
    elif abs_pi_multiple >= 1e-6:
        result = f"{pi_multiple * 1e6:.2f}\\pi\\,\\mu"
    elif abs_pi_multiple >= 1e-9:
        result = f"{pi_multiple * 1e9:.2f}\\pi\\,\\text{{n}}"
    elif abs_pi_multiple >= 1e-12:
        result = f"{pi_multiple * 1e12:.2f}\\pi\\,\\text{{p}}"
    elif abs_pi_multiple >= 1e-15:
        result = f"{pi_multiple * 1e15:.2f}\\pi\\,\\text{{f}}"
    else:
        result = f"{pi_multiple:.0e}\\pi"

    return Markdown(f"${result}$")

# Exemplo de uso:

```



# Introdução

```{python}
#| echo: false
import math

zeta = 0.707
f_bw = 150e3
omega_bw = 2*math.pi*f_bw
```

This report shows the development of a Integer-N PFD/CP-based PLL with a second-order loop filter. The loop filter is designed so that the loop bandwidth has a damping constant $\zeta=$ `{python} zeta`, and a 3-dB bandwidth of $f_{3\text{dB}}=$ `{python} format(f_bw)`Hz.


The intention here is to answer the two following questions:

- What is the maximum frequency step at the input such that the theory so far is still able to predict the behavior of the system?

- Provided this condition is met, how long will it take the system to settle from a frequency step?

To calculate the natural frequency of the loop it's used
$$
\begin{split}
\omega_{3\text{dB}}&=\omega_n\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}\implies\\
\omega_n&=\frac{\omega_{3\text{dB}}}{\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}}
\end{split}
$$

```{python}
#| echo: false
import math

omega_n=omega_bw/math.sqrt(1+2*zeta**2+math.sqrt(4*zeta**4+4*zeta**2+2))
```

So that the $\omega_n=$ `{python} format_with_pi_latex(omega_n)`rad/s. With this value, it's possible to calculate the instant that occurs the maximum value of the phase error, using the following equation

$$
t_m=\frac{1}{\omega_n\sqrt{1-\zeta^2}}\tan^{-1}\left(\frac{\sqrt{1-\zeta^2}}{\zeta}\right)
$$

```{python}
#| echo: false
import math

t_m=1/(omega_n*math.sqrt(1-zeta**2))*math.atan(math.sqrt(1-zeta**2)/zeta)
```

Then, applied in the following equation, it's gotten the maximum normalized phase error to a frequency step, $\theta_{e_\text{m,n}}$, from

$$
\begin{split}
\theta_{e_\text{m,n}}&=\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t_m\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt_m}
\end{split}
$$

```{python}
#| echo: false
import math

theta_e_m_n = math.sin(omega_n*math.sqrt(1-zeta**2)*t_m)/(math.sqrt(1-zeta**2))*math.e**(-zeta*omega_n*t_m)
theta_e_m = 2 * math.pi
```

Resulting in the maximum normalized phase error to a frequency step is about `{python} round(theta_e_m_n, 2)`. This value can be applied to the non-normalized equation of the phase error
$$
\begin{split}
\theta_e(t)&=\frac{\Delta\omega}{\omega_n}\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt}
\end{split}
$$

As the value of interest is that step frequency, $\Delta\omega_m$, that extrapolates the maximum value of phase error, $\theta_{e_m}$, that normally is $\theta_{e_m}=2\pi$. To calculate this, it's used $\theta_{e_\text{m,n}}$, as follows

$$
\begin{split}
\theta_{e_m}&=\frac{\Delta\omega_m}{\omega_n}\theta_{e_\text{m,n}}\implies\\
\Delta\omega_m&=\frac{\theta_{e_m\omega_n}}{\theta_{e_\text{m,n}}}
\end{split}
$$

```{python}
#| echo: false
import math

step_m_ang=theta_e_m*omega_n/theta_e_m_n
step_m_lin = step_m_ang/2/math.pi
```

Applying the already obtained values, it results in $\Delta\omega_m=$ `{python} format_with_pi_latex(step_m_ang)`rad/s, or `{python} format(step_m_lin)`Hz.





# References {-}
