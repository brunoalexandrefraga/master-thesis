---
title: Integer-N Frequency Synthesizer Designed for Settling Time Compliance
subtitle: Case Study - Example 3.3 from the Reference Material
author:
  - name: Bruno Alexandre Fraga
    email: bruno.fraga@posgrad.ufsc.br
    affiliations: 
        - id: some-tech
          name: Universidade Federal de Santa Catarina
          department: Departamento de Engenharia Elétrica e Eletrônica
          address: R. Delfino Conti
          city: Florianópolis
          state: Santa Catarina
          postal-code: 88040-370
abstract: |
    This report presents the design of an integer-N frequency synthesizer, focusing on the theoretical and practical aspects of system dimensioning. The objective is to ensure precise frequency generation within a specified range, while meeting constraints related to frequency resolution and settling time. The design methodology involves the definition of key dynamic parameters, such as natural frequency, damping factor, and loop bandwidth, based on continuous-time control theory. A voltage-controlled oscillator (VCO) is configured to provide the required tuning range, accounting for process variations and voltage supply limitations. Additionally, a second-order passive loop filter is designed to ensure stability and appropriate dynamic response. The overall approach demonstrates a systematic framework for the design of simple frequency synthesizers.
keywords: 
    - Integer-N PLL 
    - Settling Time
    - Continuous-Time Analysis
date: last-modified
bibliography:
  - bibliography.bib
  - zoterobibliography.bib
format:
  elsevier-pdf:
    include-in-header:
      - text: |
          \usepackage{steinmetz}
          \usepackage[a4paper, margin=1in]{geometry}
          \usepackage{graphicx} % Required for inserting images
          \usepackage{circuitikz}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{amsthm}
          \usepackage{comment}
          \usepackage{tikz}
          \usetikzlibrary{shapes,arrows}
          \usetikzlibrary{shapes,arrows,positioning,calc}


          \newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}
    keep-tex: true
    journal:
      name: Programa de Pós-Graduação em Engenharia Elétrica
      formatting: preprint
      # model: 3p # Don't set a model with preprint
      cite-style: number
---

```{python}
#| echo: false

from IPython.display import display, Markdown

def format(value, decimals=2):
    abs_value = abs(value)
    fmt = f".{decimals}f"
    
    if abs_value >= 1e9:
        result = f"{value / 1e9:{fmt}}\\,\\text{{G}}"
    elif abs_value >= 1e6:
        result = f"{value / 1e6:{fmt}}\\,\\text{{M}}"
    elif abs_value >= 1e3:
        result = f"{value / 1e3:{fmt}}\\,\\text{{k}}"
    elif abs_value >= 1:
        result = f"{value * 1e0:{fmt}}\\,"
    elif abs_value >= 1e-3:
        result = f"{value * 1e3:{fmt}}\\,\\text{{m}}"
    elif abs_value >= 1e-6:
        result = f"{value * 1e6:{fmt}}\\,\\mu"
    elif abs_value >= 1e-9:
        result = f"{value * 1e9:{fmt}}\\,\\text{{n}}"
    elif abs_value >= 1e-12:
        result = f"{value * 1e12:{fmt}}\\,\\text{{p}}"
    elif abs_value >= 1e-15:
        result = f"{value * 1e15:{fmt}}\\,\\text{{f}}"
    else:
        result = f"{value:.0e}\\,"

    return Markdown(f"${result}$")

```

```{python}
#| echo: false
import math
from IPython.display import display, Markdown

def format_with_pi_latex(value):
    pi_multiple = value / math.pi
    abs_pi_multiple = abs(pi_multiple)

    if abs_pi_multiple >= 1e9:
        result = f"{pi_multiple / 1e9:.2f}\\pi\\,\\text{{G}}"
    elif abs_pi_multiple >= 1e6:
        result = f"{pi_multiple / 1e6:.2f}\\pi\\,\\text{{M}}"
    elif abs_pi_multiple >= 1e3:
        result = f"{pi_multiple / 1e3:.2f}\\pi\\,\\text{{k}}"
    elif abs_pi_multiple >= 1:
        result = f"{pi_multiple:.2f}\\pi"
    elif abs_pi_multiple >= 1e-3:
        result = f"{pi_multiple * 1e3:.2f}\\pi\\,\\text{{m}}"
    elif abs_pi_multiple >= 1e-6:
        result = f"{pi_multiple * 1e6:.2f}\\pi\\,\\mu"
    elif abs_pi_multiple >= 1e-9:
        result = f"{pi_multiple * 1e9:.2f}\\pi\\,\\text{{n}}"
    elif abs_pi_multiple >= 1e-12:
        result = f"{pi_multiple * 1e12:.2f}\\pi\\,\\text{{p}}"
    elif abs_pi_multiple >= 1e-15:
        result = f"{pi_multiple * 1e15:.2f}\\pi\\,\\text{{f}}"
    else:
        result = f"{pi_multiple:.0e}\\pi"

    return Markdown(f"${result}$")

# Exemplo de uso:

```

```{python}
#| echo: false

f0=2.4e9
f=2.4835e9
t_s = 225e-6
f_ref = 1e6
```

# Introduction

This report presents the design of an integer-N frequency synthesizer operating from `{python} format(f0)`Hz to `{python} format(f, 4)`Hz. The synthesizer is required to achieve frequency settling within a time of $t_s=$ `{python} format(t_s)`s. Given that the channel spacing is `{python} format(f_ref)`Hz and an integer-N architecture is employed, the channel spacing is equal to the reference frequency. This example is based on the methodology and parameters provided in @rogers2006IntegratedCircuitDesign.

# Design Methodology

## Frequency Settling and Loop Dynamics

To meet the settling time requirement, the natural frequency $\omega_n$ of the loop must be determined. Using an equation discussed in a previous report, the relationship between settling time, damping factor $\zeta$, and natural frequency is given by:

$$
t_s\approx\frac{-\ln\left(0.01\sqrt{1-\zeta^2}\right)}{\zeta}\frac{1}{\omega_n}
$$

```{python}
#| echo: false
import math

zeta=0.707
omega_n__t_s=math.log(0.01*math.sqrt(1-zeta**2), math.e)/(zeta)*(-1)
omega_n=omega_n__t_s/t_s
f_n=omega_n/(2*math.pi)
```

Assuming an arbitrary value of $\zeta=$ `{python} zeta`, the resulting natural frequency is $\omega_n=$ `{python} format_with_pi_latex(omega_n)`rad/s, which corresponds to a frequency $f_n=$ `{python} format(f_n)`Hz.

From the natural frequency and damping factor, the 3-dB bandwidth $\omega_{3\text{dB}}$ can be calculated as:

$$
\omega_{3\text{dB}}=\omega_n\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}
$$

```{python}
#| echo: false
import math

omega_bw = omega_n * math.sqrt(1+2*zeta**2+math.sqrt(4*zeta**4+4*zeta**2+2))
f_bw = omega_bw/(2*math.pi)
```

This results in a bandwidth of $f_{3\text{dB}}=$ `{python} format(f_bw)`Hz. Given that $f_\text{ref}\gg f_{3\text{dB}}$, the discretization effects due to sampling are negligible, and a continuous-time analysis remains valid for this system.

```{python}
#| echo: false
N0=f0/f_ref
N=f/f_ref
```

Since the architecture is integer-N and the reference frequency is $f_\text{ref}=$ `{python} format(f_ref)`Hz, the division ratio $N$ must range from `{python} round(N0, 0)` to `{python} round(N, 0)`.

## Voltage-Controlled Oscillator (VCO)

```{python}
#| echo: false
import math

f_range=f-f0
tuning_range_percent = 9.6 
tuning_range = f0/tuning_range_percent
V=2
Kvco = 250e6 # Hz/V
Kvco_ang = Kvco*2*math.pi
```

The VCO must span a tuning range of `{python} format(f_range)`Hz. To account for process variations, an additional tuning margin is considered. A total tuning range of approximately `{python} round(tuning_range_percent, 0)`% of the center frequency, or about `{python} format(tuning_range)`Hz, is recommended.

Assuming a supply voltage of `{python} format(V)`V, a VCO gain of `{python} format(Kvco)`Hz/V (or `{python} format(Kvco_ang)`rad/s/V) is expected. The free-running frequency of the VCO is set at the minimum frequency. The center frequency $f_c$ is given by:

$$
f_c=\frac{f+f_0}{2}
$$

```{python}
#| echo: false 

f_c=(f+f0)/2
fvco=f_min=f_c-tuning_range
f_max=f_c+tuning_range

f_example_1=2.401e9
```

This results in $f_c=$ `{python} format(f_c)`Hz. Therefore, the minimum and maximum VCO frequencies are $f_\text{min}=$ `{python} format(f_min)`Hz and $f_\text{max}=$ `{python} format(f_max)`Hz, respectively. The free-running frequency is set as $f_\text{VCO}=f_\text{min}$.

For instance, to synthesize a frequency of `{python} format(f_example_1, 3)`Hz, the required control voltage $V_c$ is computed using:

$$
\begin{split}
f_o&=f_\text{VCO}+K_\text{VCO}\cdot V_c\implies\\
V_c&=\frac{f_o-f_\text{VCO}}{K_\text{VCO}}
\end{split}
$$

```{python}
#| echo: false

V_c_example_1=(f_example_1-fvco)/Kvco
```

This yields a control voltage of $V_c=$ `{python} format(V_c_example_1)`V.

## Loop filter

As previously noted, continuous-time analysis is applicable. Standard second-order loop filter equations are used. The first capacitor $C_1$ can be calculated from:

$$
C_1=\frac{I_\text{CP}K_\text{VCO}}{2\pi\cdot N\omega_n^2}
$$

```{python}
#| echo: false

import math 

C_1=5e-9
I_CP_ang=C_1*2*math.pi*N0*omega_n**2/Kvco_ang
I_CP=C_1*2*math.pi*N0*omega_n**2/Kvco

``` 

Since the charge pump current $I_\text{CP}$ is unknown, a value of $C_1=$ `{python} format(C_1)`F is assumed, leading to a calculated $I_\text{CP}=$ `{python} format(I_CP_ang)`A. The resistor $R_1$ is then given by:

$$
R_1=2\zeta\sqrt{\frac{2\pi\cdot N}{IK_\text{VCO}C_1}}
$$

```{python}
#| echo: false

import math 

R_1=2*zeta*math.sqrt((2*math.pi*N0)/(I_CP*Kvco*C_1))

```

Thus, the resistor value is $R=$ `{python} format(R_1)`$\Omega$.

Using a common design heuristic, the second capacitor $C_2$ is:

$$
C_2=\frac{C_1}{10}
$$

```{python}
#| echo: false

C_2=C_1/10 
```

Which results in $C_2=$ `{python} format(C_2)`F.

# Parameters

## Maximum Phase Error Instant

Given the value of $\omega_n$, the time instant at which the maximum phase error occurs, $t_m$, can be computed using:

$$
t_m=\frac{1}{\omega_n\sqrt{1-\zeta^2}}\tan^{-1}\left(\frac{\sqrt{1-\zeta^2}}{\zeta}\right)
$$ {#eq-instant-maximum-frequency-step}

```{python}
#| echo: false
import math

t_m=1/(omega_n*math.sqrt(1-zeta**2))*math.atan(math.sqrt(1-zeta**2)/zeta)
```

[Eq. @eq-instant-maximum-frequency-step] represents the instant at which [Eq. @eq-inverse-laplace-phase-error] reaches its maximum value.

## Maximum Normalized Phase Error

First of all, instead of using the [Eq. @eq-inverse-laplace-phase-error] and apply $t_m$, it's calculated the maximum normalized phase error, which is the same equation normalized by the input signal ($\Delta\omega$) and the natural frequency ($\omega_n$). So the maximum normalized phase error, $\theta_{e_\text{m,n}}$, is given by:

$$
\begin{split}
\theta_{e_\text{m,n}}&=\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t_m\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt_m}
\end{split}
$$

```{python}
#| echo: false
import math

theta_e_m_n = math.sin(omega_n*math.sqrt(1-zeta**2)*t_m)/(math.sqrt(1-zeta**2))*math.e**(-zeta*omega_n*t_m)
theta_e_m = 2 * math.pi
```

And applying $t_m$ to this equation, the maximum normalized phase error in this case is approximately `{python} round(theta_e_m_n, 2)`.

## Maximum Allowed Frequency Step

This normalized value can be used in the following non-normalized equation for the phase error:

$$
\begin{split}
\theta_e(t)&=\frac{\Delta\omega}{\omega_n}\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt}
\end{split}
$$

The goal is to find the maximum input frequency step, $\Delta\omega_m$, such that the maximum phase error does not exceed $\theta_{e_m}=2\pi$. Using the normalized result:

$$
\begin{split}
\theta_{e_m}&=\frac{\Delta\omega_m}{\omega_n}\theta_{e_\text{m,n}}\implies\\
\Delta\omega_m&=\frac{\theta_{e_m}\omega_n}{\theta_{e_\text{m,n}}}
\end{split}
$$

```{python}
#| echo: false
import math

step_m_ang=theta_e_m*omega_n/theta_e_m_n
step_m_lin = step_m_ang/2/math.pi
```

Substituting the calculated values yields:

- $\Delta\omega_m=$ `{python} format_with_pi_latex(step_m_ang)`rad/s
- $\Delta f_m=$ `{python} format(step_m_lin)`Hz

Hence, the maximum input frequency step that still allows theoretical predictability is `{python} format(step_m_lin)`Hz. If the input frequency step exceeds this limit, the PLL may lose lock and exhibit cycle slipping (more details are provided in the next section).

## Settling Time Estimation

The settling time, $t_s$, required for the system to reach a steady state after a frequency step can be approximated by:

$$
t_s\approx\frac{-\ln\left(0.01\sqrt{1-\zeta^2}\right)}{\zeta}\frac{1}{\omega_n}
$$

```{python}
#| echo: false
import math

t_s=math.log(0.01*math.sqrt(1-zeta**2), math.e)/(zeta*omega_n)*(-1)
```

This results in a settling time of $t_s=$ `{python} format(t_s)`s.


# Conclusion

This report has outlined the key steps in designing an integer-N frequency synthesizer operating within the specified frequency range. A continuous-time model was adopted due to the large separation between the reference frequency and the loop bandwidth. Component values for the VCO and loop filter were estimated based on reasonable assumptions, providing a solid foundation for subsequent implementation and simulation.


# References {-}
