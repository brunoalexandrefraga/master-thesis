---
title: Exploring the Validity Range of PLL Analytical Models
subtitle: Case Study - Example 3.2 from the Reference Material
author:
  - name: Bruno Alexandre Fraga
    email: bruno.fraga@posgrad.ufsc.br
    affiliations: 
        - id: some-tech
          name: Universidade Federal de Santa Catarina
          department: Departamento de Engenharia Elétrica e Eletrônica
          address: R. Delfino Conti
          city: Florianópolis
          state: Santa Catarina
          postal-code: 88040-370
abstract: |
    This report presents the analytical development and performance estimation of a second-order Integer-N Phase-Locked Loop (PLL) based on a Phase-Frequency Detector (PFD) and a Charge Pump (CP). The loop filter is designed to meet specified damping and bandwidth characteristics. The analysis determines the maximum allowable frequency step at the input that ensures the PLL remains in lock, based on the system's maximum normalized phase error. Additionally, the settling time following such a frequency step is estimated using classical control theory. The results provide useful insights into the dynamic behavior of the loop, serving as a theoretical benchmark for future simulation and implementation efforts.
keywords: 
    - Integer-N PLL
    - Loop Dynamics
    - Frequency Step
    - Settling Time 
date: last-modified
bibliography:
  - bibliography.bib
  - zoterobibliography.bib
format:
  elsevier-pdf:
    include-in-header:
      - text: |
          \usepackage{steinmetz}
          \usepackage[a4paper, margin=1in]{geometry}
          \usepackage{graphicx} % Required for inserting images
          \usepackage{circuitikz}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{amsthm}
          \usepackage{comment}
          \usepackage{tikz}
          \usetikzlibrary{shapes,arrows}
          \usetikzlibrary{shapes,arrows,positioning,calc}


          \newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}
    keep-tex: true
    journal:
      name: Programa de Pós-Graduação em Engenharia Elétrica
      formatting: preprint
      # model: 3p # Don't set a model with preprint
      cite-style: number
---

```{python}
#| echo: false

from IPython.display import display, Markdown

def format(value):
    abs_value = abs(value)
    if abs_value >= 1e9:
        result = f"{value / 1e9:.2f}\\,\\text{{G}}"
    elif abs_value >= 1e6:
        result = f"{value / 1e6:.2f}\\,\\text{{M}}"
    elif abs_value >= 1e3:
        result = f"{value / 1e3:.2f}\\,\\text{{k}}"
    elif abs_value >= 1:
        result = f"{value * 1e0:.2f}\\,"
    elif abs_value >= 1e-3:
        result = f"{value * 1e3:.2f}\\,\\text{{m}}"
    elif abs_value >= 1e-6:
        result = f"{value * 1e6:.2f}\\,\\mu"
    elif abs_value >= 1e-9:
        result = f"{value * 1e9:.2f}\\,\\text{{n}}"
    elif abs_value >= 1e-12:
        result = f"{value * 1e12:.2f}\\,\\text{{p}}"
    elif abs_value >= 1e-15:
        result = f"{value * 1e15:.2f}\\,\\text{{f}}"
    else:
        result = f"{value:.0e}\\,"

    return Markdown(f"${result}$")
```

```{python}
#| echo: false
import math
from IPython.display import display, Markdown

def format_with_pi_latex(value):
    pi_multiple = value / math.pi
    abs_pi_multiple = abs(pi_multiple)

    if abs_pi_multiple >= 1e9:
        result = f"{pi_multiple / 1e9:.2f}\\pi\\,\\text{{G}}"
    elif abs_pi_multiple >= 1e6:
        result = f"{pi_multiple / 1e6:.2f}\\pi\\,\\text{{M}}"
    elif abs_pi_multiple >= 1e3:
        result = f"{pi_multiple / 1e3:.2f}\\pi\\,\\text{{k}}"
    elif abs_pi_multiple >= 1:
        result = f"{pi_multiple:.2f}\\pi"
    elif abs_pi_multiple >= 1e-3:
        result = f"{pi_multiple * 1e3:.2f}\\pi\\,\\text{{m}}"
    elif abs_pi_multiple >= 1e-6:
        result = f"{pi_multiple * 1e6:.2f}\\pi\\,\\mu"
    elif abs_pi_multiple >= 1e-9:
        result = f"{pi_multiple * 1e9:.2f}\\pi\\,\\text{{n}}"
    elif abs_pi_multiple >= 1e-12:
        result = f"{pi_multiple * 1e12:.2f}\\pi\\,\\text{{p}}"
    elif abs_pi_multiple >= 1e-15:
        result = f"{pi_multiple * 1e15:.2f}\\pi\\,\\text{{f}}"
    else:
        result = f"{pi_multiple:.0e}\\pi"

    return Markdown(f"${result}$")

# Exemplo de uso:

```

# Introduction

```{python}
#| echo: false
import math

zeta = 0.707
f_bw = 150e3
omega_bw = 2*math.pi*f_bw
```

This report presents the development of an Integer-N Phase-Frequency Detector/Charge Pump-based Phase-Locked Loop (PFD/CP-PLL) with a second-order loop filter. The loop filter is designed so that the loop bandwidth has a damping factor $\zeta=$ `{python} zeta`, and a 3-dB bandwidth of $f_{3\text{dB}}=$ `{python} format(f_bw)`Hz. The example analyzed in this report is based on the case presented in @rogers2006IntegratedCircuitDesign.

## Objective

The objective of this study is to answer the following two questions:

- What is the maximum frequency step at the input such that the current theoretical model remains valid in predicting the system's behavior?
- Assuming this condition is satisfied, how long will the system take to settle following a frequency step?

# Analysis

For the analysis of the linear transient behavior of a PLL, the phase error, rather than the output phase, is needed. So, from the [Fig. @fig-PLL-integerN-blocks], it's possible to get the relation between the phase error, $\theta_e$, and the input phase reference, $\theta_R$. This transfer function can be expressed as:

$$
\begin{split}
\frac{\theta_e}{\theta_R}&=\frac{s^2}{s^2+2\zeta\omega_ns+\omega_n^2}
\end{split}
$$ {#eq-phase-error-transfer-function}

![Block diagram of Integer-N](../images/PLL_integerN_blocks.png){#fig-PLL-integerN-blocks}

The example whose the resolution is being given here is studying the effect of an input frequency step. Since the input is described by phase, as it's possible to be seen in [Eq. @eq-phase-error-transfer-function] ($\theta_R$), it's possible to take the phase equivalent of a frequency step, which is a phase ramp, since the phase is the integral of frequency, and the integral of a step is a ramp. Thus, the input can be described as:

$$
\theta_R=\frac{\Delta\omega}{s^2}
$$ {#eq-phase-of-frequency-step}

Multiplying the reference phase of [Eq. @eq-phase-of-frequency-step] to the [Eq. @eq-phase-error-transfer-function], results in:

$$
\begin{split}
\theta_e&=\frac{\Delta\omega}{s^2+2\zeta\omega_ns+\omega_n^2}
\end{split}
$$

And getting the inverse Laplace transform, for $\zeta<1$, results in:

$$
\theta_e(t)=\Delta\omega\cdot\frac{1}{\omega_n\sqrt{1-\zeta^2}}e^{-\zeta\omega_n t}\sin\left(\omega_n\sqrt{1-\zeta^2}t\right)
$$ {#eq-inverse-laplace-phase-error}

## Loop Natural Frequency Calculation

To compute the natural frequency of the loop, the following equation is used:

$$
\begin{split}
\omega_{3\text{dB}}&=\omega_n\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}\implies\\
\omega_n&=\frac{\omega_{3\text{dB}}}{\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}}
\end{split}
$$

```{python}
#| echo: false
import math

omega_n=omega_bw/math.sqrt(1+2*zeta**2+math.sqrt(4*zeta**4+4*zeta**2+2))
```

Thus, the natural frequency is $\omega_n=$ `{python} format_with_pi_latex(omega_n)`rad/s.

## Maximum Phase Error Instant

Given the value of $\omega_n$, the time instant at which the maximum phase error occurs, $t_m$, can be computed using:

$$
t_m=\frac{1}{\omega_n\sqrt{1-\zeta^2}}\tan^{-1}\left(\frac{\sqrt{1-\zeta^2}}{\zeta}\right)
$$ {#eq-instant-maximum-frequency-step}

```{python}
#| echo: false
import math

t_m=1/(omega_n*math.sqrt(1-zeta**2))*math.atan(math.sqrt(1-zeta**2)/zeta)
```

[Eq. @eq-instant-maximum-frequency-step] represents the instant at which [Eq. @eq-inverse-laplace-phase-error] reaches its maximum value.

## Maximum Normalized Phase Error

First of all, instead of using the [Eq. @eq-inverse-laplace-phase-error] and apply $t_m$, it's calculated the maximum normalized phase error, which is the same equation normalized by the input signal ($\Delta\omega$) and the natural frequency ($\omega_n$). So the maximum normalized phase error, $\theta_{e_\text{m,n}}$, is given by:

$$
\begin{split}
\theta_{e_\text{m,n}}&=\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t_m\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt_m}
\end{split}
$$

```{python}
#| echo: false
import math

theta_e_m_n = math.sin(omega_n*math.sqrt(1-zeta**2)*t_m)/(math.sqrt(1-zeta**2))*math.e**(-zeta*omega_n*t_m)
theta_e_m = 2 * math.pi
```

And applying $t_m$ to this equation, the maximum normalized phase error in this case is approximately `{python} round(theta_e_m_n, 2)`.

## Maximum Allowed Frequency Step

This normalized value can be used in the following non-normalized equation for the phase error:

$$
\begin{split}
\theta_e(t)&=\frac{\Delta\omega}{\omega_n}\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt}
\end{split}
$$

The goal is to find the maximum input frequency step, $\Delta\omega_m$, such that the maximum phase error does not exceed $\theta_{e_m}=2\pi$. Using the normalized result:

$$
\begin{split}
\theta_{e_m}&=\frac{\Delta\omega_m}{\omega_n}\theta_{e_\text{m,n}}\implies\\
\Delta\omega_m&=\frac{\theta_{e_m}\omega_n}{\theta_{e_\text{m,n}}}
\end{split}
$$

```{python}
#| echo: false
import math

step_m_ang=theta_e_m*omega_n/theta_e_m_n
step_m_lin = step_m_ang/2/math.pi
```

Substituting the calculated values yields:

- $\Delta\omega_m=$ `{python} format_with_pi_latex(step_m_ang)`rad/s
- $\Delta f_m=$ `{python} format(step_m_lin)`Hz

Hence, the maximum input frequency step that still allows theoretical predictability is `{python} format(step_m_lin)`Hz. If the input frequency step exceeds this limit, the PLL may lose lock and exhibit cycle slipping (more details are provided in the next section).

## Settling Time Estimation

The settling time, $t_s$, required for the system to reach a steady state after a frequency step can be approximated by:

$$
t_s\approx\frac{-\ln\left(0.01\sqrt{1-\zeta^2}\right)}{\zeta}\frac{1}{\omega_n}
$$

```{python}
#| echo: false
import math

t_s=math.log(0.01*math.sqrt(1-zeta**2), math.e)/(zeta*omega_n)*(-1)
```

This results in a settling time of $t_s=$ `{python} format(t_s)`s.

# Cycle Slipping

Cycle slipping is an undesired phenomenon in Phase-Locked Loops (PLLs) that occurs when the phase error between the reference input and the feedback output exceeds the linear range of the system.

Cycle slipping occurs when the PLL is unable to maintain phase lock, and the phase error grows beyond $2\pi$, resulting in a temporary loss of synchronization. The loop then slips by one or more full cycles before attempting to reacquire lock.

# Simulation

```{python}
#| echo: false

import numpy as np

# Parâmetros iniciais
N = 5
A0 = 1
KVCO = 10e6
I = 1e-3
Kphase = I / (2 * np.pi)
K = A0 * Kphase * KVCO / N
```

```{python}
#| echo: false

from scipy import signal

omega_n = omega_bw / np.sqrt(1 + 2 * zeta**2 + np.sqrt(4 * zeta**4 + 4 * zeta**2 + 2))
f_n = omega_n/2/np.pi

# Parâmetros do PLL
C1 = (Kphase * KVCO) / (N * omega_n**2)
C2 = C1 / 10
R1 = (zeta * 4 * np.pi * N * omega_n) / (I * KVCO)
Cs = C1 * C2 / (C1 + C2)
```

```{python}
#| echo: false

import math
import numpy as np

# Análise de resposta em frequência
omega_n_meas = np.sqrt(KVCO * Kphase / (N * (C1 + C2)))
zeta_meas = (C1 * R1 / 2) * np.sqrt(KVCO * Kphase / (N * (C1 + C2)))
t_m_meas=1/(omega_n_meas*math.sqrt(1-zeta_meas**2))*math.atan(math.sqrt(1-zeta_meas**2)/zeta_meas)
theta_e_m_n_meas = math.sin(omega_n_meas*math.sqrt(1-zeta_meas**2)*t_m_meas)/(math.sqrt(1-zeta_meas**2))*math.e**(-zeta_meas*omega_n_meas*t_m_meas)
theta_e_m_meas = 2 * math.pi

step_m_ang_meas=theta_e_m_meas*omega_n_meas/theta_e_m_n_meas
step_m_lin_meas = step_m_ang_meas/2/math.pi

t_s_meas=math.log(0.01*math.sqrt(1-zeta_meas**2), math.e)/(zeta*omega_n_meas)*(-1)
```

```{python}
#| echo: false

# Numerador e denominador do compensador F(s)
# F(s) = (s*C1*R1 + 1) / (s^2*C1*C2*R1 + s*(C1 + C2))
F_num = [C1 * R1, 1]
F_den = [C1 * C2 * R1, C1 + C2, 0]

# F(s) * K / s = G(s)
G_num = np.polymul(F_num, [K])
G_den = np.polymul(F_den, [1, 0])  # Multiplica por s

# H(s) = G(s) / (1 + G(s))
H_num = G_num
H_den = np.polyadd(G_den, G_num)

# Criando o sistema de tempo contínuo
H_sys = signal.TransferFunction(H_num, H_den)

```

```{python}
#| echo: false
#| label: fig-pll-step-response
#| fig-cap: "Closed-loop step response of the designed PLL."
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 30e-6, 100000)

# Criar vetor da entrada (degrau de amplitude 5)
step_amplitude = 2*step_m_ang_meas
u = np.ones_like(t) * step_amplitude

# Simulação da resposta ao degrau via lsim
t_out, y_out, _ = signal.lsim(H_sys, U=u, T=t)

# Valor final da resposta
final_value = y_out[-1]
tol = 0.01 * final_value  # 1% da resposta final

# Encontrar o tempo em que a resposta entra e permanece na faixa de ±1%
within_bounds = np.abs(y_out - u) <= tol
for i in range(len(within_bounds)):
    if all(within_bounds[i:]):
        ts_graphical = t_out[i]
        break

# Gerar gráfico
plt.figure(figsize=(8, 5))
plt.plot(t_out * 1e6, y_out, label='Resposta ao Degrau')
plt.plot(t_out * 1e6, u, linestyle=':', color='black', label='Entrada Degrau')
plt.axhline(final_value + tol, color='red', linestyle='--', linewidth=0.8, label='Faixa ±1%')
plt.axhline(final_value - tol, color='red', linestyle='--', linewidth=0.8)
plt.axvline(ts_graphical * 1e6, color='green', linestyle='--', linewidth=1.2, label=f'Settling time (gráfico): {ts_graphical*1e6:.2f} µs')
plt.xlabel('Tempo [µs]')
plt.ylabel('Resposta')
plt.title('Resposta ao Degrau com Tempo de Acomodação (99%)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```

Using the parameters $\omega_n$ and $\zeta$, the transfer function of the entire loop can be described as (neglecting the second capacitor, $C_2$, of the filter):

$$
\frac{\theta_o}{\theta_R}=\frac{\omega_n^2\left(\frac{2\zeta}{\omega_n}s+1\right)}{s^2+2\zeta\omega_n s+\omega_n^2}
$$ {#eq-full-transfer-function-no-C2}

An integer-N Phase-Locked Loop (PLL) was developed with a division factor of $N=$ `{python} N`. The system was designed with a VCO gain of $K_\mathrm{VCO}=$ `{python} format(KVCO)`Hz/V, and a charge pump current of $I=$ `{python} format(I)`A. The phase detector gain is given by $K_\theta=I/2\pi$, resulting in $K_\theta=$ `{python} format(Kphase)`A/rad.

The natural frequency of the loop, $\omega_n$, was computed from the loop bandwidth $\omega_\mathrm{bw}$ and damping factor $\zeta$, yielding a natural frequency $f_n=\omega_n/2\pi=$ `{python} format(f_n)`Hz.

Based on the chosen parameters, the loop filter components were calculated as follows. The primary capacitor of the loop filter is:

$$
C_1 = \frac{K_\theta K_\mathrm{VCO}}{N \omega_n^2}
$$

That is, $C_1=$ `{python} format(C1)`F.

The second capacitor is chosen to be one-tenth of $C_1$, i.e., $C_2=$ `{python} format(C2)`F.

The resistor of the loop filter is given by:

$$
R_1 = \frac{\zeta 4 \pi N \omega_n}{I K_\mathrm{VCO}}
$$

That is, $R_1=$ `{python} format(R1)`$\Omega$.

These component values define the loop filter required to achieve the desired dynamic behavior of the PLL.

Similarlly what was presented in [Eq. @eq-full-transfer-function-no-C2], it's possible to present the transfer function of the system in terms of components values. This transfer function can be seen below (this equation uses the second capacitor, $C_2$, of the loop filter, adding a high-frequency pole to the system):

$$
\begin{split}
\frac{\theta_o}{\theta_R}&=\frac{K_\mathrm{VCO}K_\theta\left(1+sC_1R\right)}{s^2N\left(C_1+C_2\right)\left(1+sC_sR\right)+K_\mathrm{VCO}K_\theta\left(1+sC_1R\right)}
\end{split}
$$


With the second-order PLL properly defined, the transfer function of this system is given by:

```{python}
#| echo: false

import sympy as sp
from IPython.display import display, Markdown

# Define variáveis simbólicas
s, wn, z = sp.symbols('s omega_n_meas zeta_meas')

# Define numerador e denominador simbolicamente
Hnum = 2 * z * wn * s + wn**2
Hden = s**2 + 2 * z * wn * s + wn**2

H = Hnum / Hden

H_subs = H.subs({wn: omega_n_meas, z: zeta_meas}).evalf(4)

# Converte para LaTeX
latex_str = sp.latex(H_subs)

# Exibe como Markdown numerado
display(Markdown(f"$$H(s) = {latex_str}$$ {{#eq-transfer-function}}"))

```

A step with the same amplitude as the previously calculated frequency step was also applied in phase, that is, $\Delta\theta=$ `{python} format_with_pi_latex(step_m_ang_meas)`rad/s. Applying this signal to [Eq. @eq-transfer-function], the response of this system to the phase step is obtained. With this step, the settling time achieved is $t_s=$ `{python} format(t_s_meas)`s. Through simulation, it is possible to verify that the obtained value is $t_s=$ `{python} format(ts_graphical)` s. The simulated response can be visualized in [Fig. @fig-pll-step-response].


# Conclusion

This report provides a theoretical analysis of a second-order PFD/CP-based Integer-N PLL. The maximum tolerable frequency step for which the linear model remains valid was derived, and the corresponding settling time was estimated. These results serve as a foundation for further simulation and validation studies.

# References {-}
