---
title: Exploring the Validity Range of PLL Analytical Models
subtitle: Case Study - Example 3.2 from the Reference Material
author:
  - name: Bruno Alexandre Fraga
    email: bruno.fraga@posgrad.ufsc.br
    affiliations: 
        - id: some-tech
          name: Universidade Federal de Santa Catarina
          department: Departamento de Engenharia Elétrica e Eletrônica
          address: R. Delfino Conti
          city: Florianópolis
          state: Santa Catarina
          postal-code: 88040-370
abstract: |
    This report presents the analytical development and performance estimation of a second-order Integer-N Phase-Locked Loop (PLL) based on a Phase-Frequency Detector (PFD) and a Charge Pump (CP). The loop filter is designed to meet specified damping and bandwidth characteristics. The analysis determines the maximum allowable frequency step at the input that ensures the PLL remains in lock, based on the system's maximum normalized phase error. Additionally, the settling time following such a frequency step is estimated using classical control theory. The results provide useful insights into the dynamic behavior of the loop, serving as a theoretical benchmark for future simulation and implementation efforts.
keywords: 
    - Integer-N PLL
    - Loop Dynamics
    - Frequency Step
    - Settling Time 
date: last-modified
bibliography:
  - bibliography.bib
  - zoterobibliography.bib
format:
  elsevier-pdf:
    include-in-header:
      - text: |
          \usepackage{steinmetz}
          \usepackage[a4paper, margin=1in]{geometry}
          \usepackage{graphicx} % Required for inserting images
          \usepackage{circuitikz}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{amsthm}
          \usepackage{comment}
          \usepackage{tikz}
          \usetikzlibrary{shapes,arrows}
          \usetikzlibrary{shapes,arrows,positioning,calc}


          \newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}
    keep-tex: true
    journal:
      name: Programa de Pós-Graduação em Engenharia Elétrica
      formatting: preprint
      # model: 3p # Don't set a model with preprint
      cite-style: number
---

```{python}
#| echo: false

from IPython.display import display, Markdown

def format_graph(value):
    abs_value = abs(value)
    if abs_value >= 1e9:
        result = f"{value / 1e9:.2f} G"
    elif abs_value >= 1e6:
        result = f"{value / 1e6:.2f} M"
    elif abs_value >= 1e3:
        result = f"{value / 1e3:.2f} k"
    elif abs_value >= 1:
        result = f"{value * 1e0:.2f} "
    elif abs_value >= 1e-3:
        result = f"{value * 1e3:.2f} m"
    elif abs_value >= 1e-6:
        result = f"{value * 1e6:.2f} μ"
    elif abs_value >= 1e-9:
        result = f"{value * 1e9:.2f} n"
    elif abs_value >= 1e-12:
        result = f"{value * 1e12:.2f} p"
    elif abs_value >= 1e-15:
        result = f"{value * 1e15:.2f} f"
    else:
        result = f"{value:.0e} "

    return result
```


```{python}
#| echo: false

from IPython.display import display, Markdown

def format_no_markdown(value):
    abs_value = abs(value)
    if abs_value >= 1e9:
        result = f"{value / 1e9:.2f}\\,\\text{{G}}"
    elif abs_value >= 1e6:
        result = f"{value / 1e6:.2f}\\,\\text{{M}}"
    elif abs_value >= 1e3:
        result = f"{value / 1e3:.2f}\\,\\text{{k}}"
    elif abs_value >= 1:
        result = f"{value * 1e0:.2f}\\,"
    elif abs_value >= 1e-3:
        result = f"{value * 1e3:.2f}\\,\\text{{m}}"
    elif abs_value >= 1e-6:
        result = f"{value * 1e6:.2f}\\,\\mu"
    elif abs_value >= 1e-9:
        result = f"{value * 1e9:.2f}\\,\\text{{n}}"
    elif abs_value >= 1e-12:
        result = f"{value * 1e12:.2f}\\,\\text{{p}}"
    elif abs_value >= 1e-15:
        result = f"{value * 1e15:.2f}\\,\\text{{f}}"
    elif abs_value >= 1e-18:
        result = f"{value * 1e18:.2f}\\,\\text{{a}}"
    else:
        result = f"{value:.0e}\\,"

    return result
```

```{python}
#| echo: false

from IPython.display import display, Markdown

def format(value):
    result = format_no_markdown(value)
    return Markdown(f"${result}$")
```

```{python}
#| echo: false
import math
from IPython.display import display, Markdown

def format_with_pi_latex(value):
    pi_multiple = value / math.pi
    abs_pi_multiple = abs(pi_multiple)

    if abs_pi_multiple >= 1e9:
        result = f"{pi_multiple / 1e9:.2f}\\pi\\,\\text{{G}}"
    elif abs_pi_multiple >= 1e6:
        result = f"{pi_multiple / 1e6:.2f}\\pi\\,\\text{{M}}"
    elif abs_pi_multiple >= 1e3:
        result = f"{pi_multiple / 1e3:.2f}\\pi\\,\\text{{k}}"
    elif abs_pi_multiple >= 1:
        result = f"{pi_multiple:.2f}\\pi"
    elif abs_pi_multiple >= 1e-3:
        result = f"{pi_multiple * 1e3:.2f}\\pi\\,\\text{{m}}"
    elif abs_pi_multiple >= 1e-6:
        result = f"{pi_multiple * 1e6:.2f}\\pi\\,\\mu"
    elif abs_pi_multiple >= 1e-9:
        result = f"{pi_multiple * 1e9:.2f}\\pi\\,\\text{{n}}"
    elif abs_pi_multiple >= 1e-12:
        result = f"{pi_multiple * 1e12:.2f}\\pi\\,\\text{{p}}"
    elif abs_pi_multiple >= 1e-15:
        result = f"{pi_multiple * 1e15:.2f}\\pi\\,\\text{{f}}"
    else:
        result = f"{pi_multiple:.0e}\\pi"

    return Markdown(f"${result}$")

# Exemplo de uso:

```

# Introduction

```{python}
#| echo: false
import math

zeta = 0.707
f_bw = 150e3
omega_bw = 2*math.pi*f_bw
```

This report presents the development of an Integer-N Phase-Frequency Detector/Charge Pump-based Phase-Locked Loop (PFD/CP-PLL) with a second-order loop filter. The loop filter is designed so that the loop bandwidth has a damping factor $\zeta=$ `{python} zeta`, and a 3-dB bandwidth of $f_{3\text{dB}}=$ `{python} format(f_bw)`Hz. The example analyzed in this report is based on the case presented in @rogers2006IntegratedCircuitDesign.

## Objective

The objective of this study is to answer the following two questions:

- What is the maximum frequency step at the input such that the current theoretical model remains valid in predicting the system's behavior?
- Assuming this condition is satisfied, how long will the system take to settle following a frequency step?

# System Modeling

A [Fig. @fig-PLL-integerN-blocks] o diagrama de blocos de um PLL Integer-N PFD/CP-based.

![Block diagram of Integer-N](../images/PLL_integerN_blocks.png){#fig-PLL-integerN-blocks}

The loop filter transfer function, $F(s)$ can be described as:

$$
F(s) = \left(R+\frac{1}{sC_1}\right)\parallelsum\frac{1}{sC_2}
$$

É possível escrever a função de transferência de malha aberta desse sistema apresentado na [Fig. @fig-PLL-integerN-blocks] como

$$
G(s) = \frac{KF(s)}{s}
$$

em que

$$
K = A_0K_\theta K_\mathrm{VCO}N^{-1}
$$

tal que $A_0$ é o ganho DC (usualmente unitário), $K_\theta=I/2\pi$ o ganho do charge pump, $K_\mathrm{VCO}$ o ganho do VCO e $N$ o divisor de frequência.

A função de transferência em malha fechada é dada por

$$
H(s)=\frac{\theta_\mathrm{fb}}{\theta_R}=\frac{\omega_\mathrm{fb}}{\omega_R}=\frac{G(s)}{1+G(s)}
$$ {#eq-PLL-closed-loop-transfer-function-initial}

## Parameters and Components

Os parâmetros do sistema podem ser calculados simplificadamente como se seguem:

$$
\omega_n = \sqrt{\frac{K}{C_1}}
$$ {#eq-omega_n-definition-no-C2}

and

$$
\zeta = \frac{R}{2}\sqrt{KC_1}
$$ {#eq-zeta-definition-no-C2}

Thus the components of the loop filter can be obtained as:

$$
C_1 = \frac{K}{\omega_n^2}
$$ {#eq-C1-loop-filter}

and

$$
R_1 = \zeta\sqrt{\frac{2\omega_n}{K}}
$$ {#eq-R1-loop-filter}

For simplicity, the second capacitor can be obtained by $C_2=C_1/10$.

## Phase Error Transfer Function

A função de transferência do erro de fase pela fase de referência pode ser obtida como

$$
E(s)=\frac{\theta_e}{\theta_R}=H(s)\cdot\frac{s}{KF(s)}
$$ {#eq-phase-error-transfer-function-initial}

The example whose the resolution is being given here is studying the effect of an input frequency step. Since the input is described by phase, as it's possible to be seen in [Eq. @eq-phase-error-transfer-function-initial] ($\theta_R$), it's possible to take the phase equivalent of a frequency step, which is a phase ramp, since the phase is the integral of frequency, and the integral of a step is a ramp. Thus, the input can be described as:

$$
\theta_R=\frac{\Delta\omega}{s^2}
$$ {#eq-phase-of-frequency-step}

Getting the inverse Laplace transform of the respose of phase error transfer function for a step frequency, for $\zeta<1$, results in the following time-domain equation:

$$
\theta_e(t)=\frac{\Delta\omega}{\omega_n}\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt}
$$ {#eq-inverse-laplace-phase-error}



### Maximum Step Frequency

Analysing the maximum of the [Eq. @eq-inverse-laplace-phase-error], the time instant at which the maximum phase error occurs, $t_m$, can be computed using:

$$
t_m=\frac{1}{\omega_n\sqrt{1-\zeta^2}}\tan^{-1}\left(\frac{\sqrt{1-\zeta^2}}{\zeta}\right)
$$ {#eq-instant-maximum-frequency-step}

[Eq. @eq-instant-maximum-frequency-step] represents the instant at which [Eq. @eq-inverse-laplace-phase-error] reaches its maximum value.

Sendo a máxima normalized phase error,

$$
\begin{split}
\theta_{e_\text{m,n}}&=\frac{\sin\left(\omega_n\sqrt{1-\zeta^2}t_m\right)}{\sqrt{1-\zeta^2}}e^{-\zeta\omega_nt_m}
\end{split}
$$

Então

$$
\theta_{e_m}=\frac{\Delta\omega_m}{\omega_n}\theta_{e_\text{m,n}}
$$

Levando a um máximo step frequency igual a

$$
\Delta\omega_m=\frac{\theta_{e_m}\omega_n}{\theta_{e_\text{m,n}}}
$$ {#eq-maximum-step-frequency}

### Settling Time Estimation

The settling time, $t_s$, required for the system to reach a steady state after a frequency step can be approximated by:

$$
t_s\approx\frac{-\ln\left(0.01\sqrt{1-\zeta^2}\right)}{\zeta}\frac{1}{\omega_n}
$$

## Voltage Control Transfer Function

A função de transferência da tensão de controle pela fase de referência pode ser obtido como

$$
V(s)=\frac{V_C}{\theta_R}=H(s)\cdot\frac{1}{1/N}\cdot\frac{1}{K_\mathrm{VCO}}
$$ {#eq-voltage-control-transfer-function-initial}


## Loop Natural Frequency Calculation

To compute the frequency bandwidth of the loop, the following equation is used:

$$
\omega_{3\text{dB}}=\omega_n\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}
$$ {#eq-frequency-bandwidth}

Rearanging the [Eq. @eq-frequency-bandwidth], it's possible to compute the natural frequency in terms of frequency bandwidth:

$$
\omega_n=\frac{\omega_{3\text{dB}}}{\sqrt{1+2\zeta^2+\sqrt{4\zeta^4+4\zeta^2+2}}}
$$ {#eq-natural-frequency-from-bandwidth}


## Cycle Slipping

Cycle slipping is an undesired phenomenon in Phase-Locked Loops (PLLs) that occurs when the phase error between the reference input and the feedback output exceeds the linear range of the system.

Cycle slipping occurs when the PLL is unable to maintain phase lock, and the phase error grows beyond $2\pi$, resulting in a temporary loss of synchronization. The loop then slips by one or more full cycles before attempting to reacquire lock.

## Validade da teoria

Para que os modelos teóricos sejam válidos é necessário respeitar the minimum frequency of the reference signal is estimated. A ratio often quoted as being safe is 10:1 for $\omega_r/\omega_n$. However, the minimum allowed frequency is given by:

$$
\frac{\omega_r}{\omega_n}\ge 2\pi\zeta
$$

Se essa regra não for respeitada, os modelos lineares não têm a mesma garantia, necessitando que a amostragem do sinal também seja levada em consideração e o sistema tratado como um sistema discreto que realmente o é.

# Design Analysis

```{python}
#| echo: false
import math

omega_n=omega_bw/math.sqrt(1+2*zeta**2+math.sqrt(4*zeta**4+4*zeta**2+2))
```

Partindo dos parâmetros já apresentados na introdução, the natural frequency is $\omega_n=$ `{python} format_with_pi_latex(omega_n)`rad/s.

```{python}
#| echo: false
import math

t_m=1/(omega_n*math.sqrt(1-zeta**2))*math.atan(math.sqrt(1-zeta**2)/zeta)
```

Calculando-se o instante em que ocorre a máxima diferença de fase obtém-se, $t_m=$ `{python} format(t_m)`s.

```{python}
#| echo: false
import math

theta_e_m_n = math.sin(omega_n*math.sqrt(1-zeta**2)*t_m)/(math.sqrt(1-zeta**2))*math.e**(-zeta*omega_n*t_m)
theta_e_m = (1.6255) * math.pi
```

And applying $t_m$ to this equation, the maximum normalized phase error in this case is approximately `{python} round(theta_e_m_n, 2)`.

Normalmente, espera-se que o máximo erro de fase suportado pelo PFD é de $2\pi$, entretanto, para coincidir com os valores obtidos com o simulador utilizado, empiricamente obtém-se um maximum phase error, $\theta_{e_m}=$ `{python} format_with_pi_latex(theta_e_m)`.

```{python}
#| echo: false
import math

step_m_ang=theta_e_m*omega_n/theta_e_m_n
step_m_lin = step_m_ang/2/math.pi
```

Substituting the calculated values na [Eq. @eq-maximum-step-frequency] yields $\Delta\omega_m=$ `{python} format_with_pi_latex(step_m_ang)`rad/s or, alternativelly, $\Delta f_m=$ `{python} format(step_m_lin)`Hz. Hence, the maximum input frequency step that still allows theoretical predictability is `{python} format(step_m_lin)`Hz. If the input frequency step exceeds this limit, the PLL may lose lock and exhibit cycle slipping (more details are provided in the next section).

```{python}
#| echo: false
import math

t_s=math.log(0.01*math.sqrt(1-zeta**2), math.e)/(zeta*omega_n)*(-1)
```

Com esse step de frequencia e todos os parâmetros calculados até então, é possível calcular o settling time de 1% de solução, resultando em $t_s=$ `{python} format(t_s)`s.

## Project

```{python}
#| echo: false

import numpy as np

# Parâmetros iniciais
f_r = 10e6 # Hz
omega_r = 2 * np.pi * f_r # rad/s
f_o = 50e6 # Hz
omega_o = 2 * np.pi * f_r # rad/s
N = 5
Kvco = KVCO = 10e6 # Hz/V
Kvco_ang = 2 * np.pi * Kvco # rad/s/V
I = 1e-3
K_theta = Kphase = I / (2 * np.pi) # A/rad
A0 = 6.258
K = A0 * Kphase * KVCO / N
```

Para exemplificar os resultados obtidos até então, an integer-N Phase-Locked Loop (PLL) was developed with a division factor of $N=$ `{python} N`. The system was designed with a VCO gain of $K_\mathrm{VCO}=$ `{python} format(KVCO)`Hz/V, and a charge pump current of $I=$ `{python} format(I)`A. The phase detector gain is given by $K_\theta=I/2\pi$. Além disso, para que seja possível coincidir os valores calculados com as respostas obtidas na simulação, foi obtido um valor empírico para o ganho dc, $A_0=$ `{python} round(A0, 2)`.


```{python}
#| echo: false

from scipy import signal

omega_n = omega_bw / np.sqrt(1 + 2 * zeta**2 + np.sqrt(4 * zeta**4 + 4 * zeta**2 + 2))
f_n = omega_n/2/np.pi
```

The natural frequency of the loop, $\omega_n$, was computed from the loop bandwidth $\omega_\mathrm{bw}$ and damping factor $\zeta$, yielding a natural frequency $f_n=\omega_n/2\pi=$ `{python} format(f_n)`Hz.

```{python}
#| echo: false

# Parâmetros do PLL
C1 = K / omega_n**2
C2 = C1 / 10
R1 = 2 * zeta * omega_n / K
```

Based on the chosen parameters, the loop filter components were calculated as follows. The primary capacitor of the loop filter is given by the [Eq. @], that is, $C_1=$ `{python} format(C1)`F. The second capacitor is chosen to be one-tenth of $C_1$, i.e., $C_2=$ `{python} format(C2)`F. The resistor of the loop filter is given by [Eq. @], that is, $R_1=$ `{python} format(R1)`$\Omega$.

```{python}
#| echo: false

import math
import numpy as np

# Análise de resposta em frequência
omega_n_meas = np.sqrt(K / C1)
f_n_meas = omega_n_meas / (2 * np.pi)

zeta_meas = (R1 / 2) * np.sqrt(K * C1)

t_m_meas = 1 / (omega_n_meas * math.sqrt(1 - zeta_meas**2)) * math.atan(math.sqrt(1 - zeta_meas**2) / zeta_meas)

theta_e_m_n_meas = math.sin(omega_n_meas * math.sqrt(1 - zeta_meas**2) * t_m_meas) / \
                   (math.sqrt(1 - zeta_meas**2)) * math.e**(-zeta_meas * omega_n_meas * t_m_meas)

theta_e_m_meas = theta_e_m

omega_bw_meas = omega_n_meas * np.sqrt(1 + 2 * zeta_meas**2 + np.sqrt(4 * zeta_meas**4 + 4 * zeta_meas**2 + 2))
f_bw_meas = omega_bw_meas / (2 * np.pi)

step_m_ang_meas = theta_e_m_meas * omega_n_meas / theta_e_m_n_meas
step_m_lin_meas = step_m_ang_meas / (2 * math.pi)

t_s_meas = math.log(0.01 * math.sqrt(1 - zeta_meas**2)) / (zeta_meas * omega_n_meas) * (-1)

```

These component values define the loop filter required to achieve the desired dynamic behavior of the PLL. With these components, it's possible to extract another set of the system parameters, i.e., $f_n=\omega_n/2\pi$, $\zeta$ and $f_\mathrm{bw}=\omega_\mathrm{bw}/2\pi$. The values are $f_n=$ `{python} format(f_n_meas)`Hz, $\zeta=$ `{python} round(zeta_meas, 3)` and $f_\mathrm{bw}=$ `{python} format(f_bw_meas)`Hz.

```{python}
#| echo: false

from scipy import signal
from IPython.display import display, Markdown

def format_eng(x):
    if x == 0:
        return "0"
    exponent = int("{:.0e}".format(x).split('e')[1])
    base = x / (10**exponent)
    return f"{base:.2f}e{exponent}"

def poly_to_str(coeffs):
    terms = []
    degree = len(coeffs) - 1
    for i, coef in enumerate(coeffs):
        power = degree - i
        if abs(coef) < 1e-12:  # ignora coeficientes muito pequenos
            continue
        term = ""
        coef_str = format_eng(coef)
        if not (abs(coef - 1) < 1e-12 and power != 0):
            term += coef_str
        if power > 0:
            term += "s"
            if power > 1:
                term += f"^{power}"
        terms.append(term)
    return " + ".join(terms)
```

A transfer function of the filter is given by:

```{python}
#| echo: false

# Numerador e denominador do compensador F(s)
# F(s) = (s*C1*R1 + 1) / (s^2*C1*C2*R1 + s*(C1 + C2))
F_num = [C1 * R1, 1]
F_den = [C1 * C2 * R1, C1 + C2, 0]

F_sys = signal.TransferFunction(F_num, F_den)
```

```{python}
#| echo: false
# Em scipy.signal, num e den são arrays dentro de listas (mesmo para SISO)
num = F_sys.num[0][0] if isinstance(F_sys.num[0], (list, tuple)) else F_sys.num
den = F_sys.den[0][0] if isinstance(F_sys.den[0], (list, tuple)) else F_sys.den

num_str = poly_to_str(num)
den_str = poly_to_str(den)

# Exibe como equação no Jupyter
display(Markdown(f"$$F(s) = \\frac{{{num_str}}}{{{den_str}}}$$ {{#eq-filter-loop-transfer-function}}"))

```

The open-loop transfer function of the system is given by:

```{python}
#| echo: false
# F(s) * K / s = G(s)
G_num = np.polymul(F_num, [K])
G_den = np.polymul(F_den, [1, 0])  # Multiplica por s

G_sys = signal.TransferFunction(G_num, G_den)
```


```{python}
#| echo: false
# Em scipy.signal, num e den são arrays dentro de listas (mesmo para SISO)
num = G_sys.num[0][0] if isinstance(G_sys.num[0], (list, tuple)) else G_sys.num
den = G_sys.den[0][0] if isinstance(G_sys.den[0], (list, tuple)) else G_sys.den

num_str = poly_to_str(num)
den_str = poly_to_str(den)

# Exibe como equação no Jupyter
display(Markdown(f"$$G(s) = \\frac{{{num_str}}}{{{den_str}}}$$ {{#eq-open-loop-num-transfer-function}}"))
```

The closed-loop transfer function of the entire system, both in frequency domain and phase domain is given by:

```{python}
#| echo: false
# H(s) = G(s) / (1 + G(s))
H_num = G_num
H_den = np.polyadd(G_den, G_num)

# Criando o sistema de tempo contínuo
H_sys = signal.TransferFunction(H_num, H_den)
```


```{python}
#| echo: false
# Em scipy.signal, num e den são arrays dentro de listas (mesmo para SISO)
num = H_sys.num[0][0] if isinstance(H_sys.num[0], (list, tuple)) else H_sys.num
den = H_sys.den[0][0] if isinstance(H_sys.den[0], (list, tuple)) else H_sys.den

num_str = poly_to_str(num)
den_str = poly_to_str(den)

# Exibe como equação no Jupyter
display(Markdown(f"$$H(s) = \\frac{{{num_str}}}{{{den_str}}}$$ {{#eq-closed-loop-num-transfer-function}}"))
```

The transfer function of the output phase is given by:

```{python}
#| echo: false
 
# Agora temos o denominador completo
# O_sys = H_sys * N
# Para isso, O_sys = (H_num * N) / (H_den)
num_O = np.convolve(H_sys.num, [N])
den_O = np.convolve(H_sys.den, [1])

# Criar a função de transferência final
O_sys = signal.TransferFunction(num_O, den_O)
```

```{python}
#| echo: false
# Em scipy.signal, num e den são arrays dentro de listas (mesmo para SISO)
num = O_sys.num[0][0] if isinstance(O_sys.num[0], (list, tuple)) else O_sys.num
den = O_sys.den[0][0] if isinstance(O_sys.den[0], (list, tuple)) else O_sys.den

num_str = poly_to_str(num)
den_str = poly_to_str(den)

# Exibe como equação no Jupyter
display(Markdown(f"$$O(s) = \\frac{{{num_str}}}{{{den_str}}}$$ {{#eq-output-phase-num-transfer-function}}"))
```


The transfer function of the phase error is given by:

```{python}
#| echo: false
 
# Kvco/s => [Kvco] / [1, 0]
Kvco_over_s = ([Kvco], [1, 0])

# F_sys => ([1], [1, 1]) já está
# Multiplicando numeradores e denominadores via convolução
num_den = np.convolve([1/N], Kvco_over_s[0])
num_den = np.convolve(num_den, F_sys.num)
num_den = np.convolve(num_den, [K_theta])
num_den = np.convolve(num_den, [A0])

den_den = np.convolve(Kvco_over_s[1], F_sys.den)

# Agora temos o denominador completo
# E_sys = H_sys / (den)
# Para isso, E_sys = (H_num * den_den) / (H_den * den_num)
num_E = np.convolve(H_sys.num, den_den)
den_E = np.convolve(H_sys.den, num_den)

# Criar a função de transferência final
E_sys = signal.TransferFunction(num_E, den_E)
```

```{python}
#| echo: false
# Em scipy.signal, num e den são arrays dentro de listas (mesmo para SISO)
num = E_sys.num[0][0] if isinstance(E_sys.num[0], (list, tuple)) else E_sys.num
den = E_sys.den[0][0] if isinstance(E_sys.den[0], (list, tuple)) else E_sys.den

num_str = poly_to_str(num)
den_str = poly_to_str(den)

# Exibe como equação no Jupyter
display(Markdown(f"$$E(s) = \\frac{{{num_str}}}{{{den_str}}}$$ {{#eq-phase-error-num-transfer-function}}"))
```

The transfer function of the voltage control is given by:

```{python}
#| echo: false

# Vc_sys = H_sys / ((1/N)*(Kvco/s))
#Kvco_over_s = ([Kvco], [1, 0])
Kvco_over_s = ([Kvco], [1])
den_num = np.convolve([1/N], Kvco_over_s[0])
den_den = Kvco_over_s[1]

num_Vc = np.convolve(H_sys.num, den_den)
den_Vc = np.convolve(H_sys.den, den_num)

Vc_sys = signal.TransferFunction(num_Vc, den_Vc)
```

```{python}
#| echo: false
# Em scipy.signal, num e den são arrays dentro de listas (mesmo para SISO)
num = Vc_sys.num[0][0] if isinstance(Vc_sys.num[0], (list, tuple)) else Vc_sys.num
den = Vc_sys.den[0][0] if isinstance(Vc_sys.den[0], (list, tuple)) else Vc_sys.den

num_str = poly_to_str(num)
den_str = poly_to_str(den)

# Exibe como equação no Jupyter
display(Markdown(f"$$V_C(s) = \\frac{{{num_str}}}{{{den_str}}}$$ {{#eq-voltage-control-num-transfer-function}}"))
```

## Validade do modelo

```{python}
#| echo: false

import numpy as np

omega_r_safe = omega_n*10
f_r_safe = omega_r_safe/2/np.pi

omega_r_max = omega_n * 2 * np.pi * zeta
f_r_max = omega_r_max/2/np.pi
```

The minimum safe frequency for the reference signal is given by $f_r=$ `{python} format(f_r_safe)`Hz. However, the minimum reference frequency is $f_r\ge$ `{python} format(f_r_max)`Hz. Therefore, since a PLL operating with a reference frequency of $f_r=$ `{python} format(f_r)`Hz and an output frequency of `{python} format(f_o)`Hz is desired, the designed system must operate correctly.




































# System Responses



```{python}
#| echo: false
#| label: fig-pll-step-response
#| fig-cap: "Step Response of the Closed-Loop Frequency Transfer Function of the PLL."
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 30e-6, 100000)

# Criar vetor da entrada (degrau de amplitude 5)
step_amplitude = 0.5e6
u = np.ones_like(t) * step_amplitude

# Simulação da resposta ao degrau via lsim
t_out, y_out, _ = signal.lsim(H_sys, U=u, T=t)

# Valor final da resposta
final_value = y_out[-1]
tol = 0.01 * final_value  # 1% da resposta final

# Encontrar o tempo em que a resposta entra e permanece na faixa de ±1%
ts_graphical = 0
within_bounds = np.abs(y_out - u) <= tol
for i in range(len(within_bounds)):
    if all(within_bounds[i:]):
        ts_graphical = t_out[i]
        break

# Gerar gráfico
plt.figure(figsize=(8, 5))
plt.plot(t_out * 1e6, y_out, label='Step Response')
plt.plot(t_out * 1e6, u, linestyle=':', color='black', label='Step')
plt.axhline(final_value + tol, color='red', linestyle='--', linewidth=0.8, label='±1% Tolerance')
plt.axhline(final_value - tol, color='red', linestyle='--', linewidth=0.8)
plt.axvline(ts_graphical * 1e6, color='green', linestyle='--', linewidth=1.2, label=f'Graphical settling time: {ts_graphical*1e6:.5f} us')
plt.xlabel('Time [us]')
plt.ylabel('Frequency (Hz)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```

A step with the same amplitude as the previously calculated frequency step was also applied in phase, that is, $\Delta\theta=$ `{python} format_with_pi_latex(step_m_ang_meas)`rad/s. Applying this signal to [Eq. @eq-transfer-function], the response of this system to the phase step is obtained. With this step, the settling time achieved is $t_s=$ `{python} format(t_s_meas)`s. Through simulation, it is possible to verify that the obtained value is $t_s=$ `{python} format(ts_graphical)`s. The simulated response can be visualized in [Fig. @fig-pll-step-response].

```{python}
#| echo: false
#| label: fig-pll-step-response-alt
#| fig-cap: "Closed-loop phase step response of the designed PLL."
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 50e-6, 100000)

# Criar vetor da entrada (degrau de amplitude 5)
step_amplitude = omega_r * t
u = np.ones_like(t) * step_amplitude

# Simulação da resposta ao degrau via lsim
t_out, y_out, _ = signal.lsim(H_sys, U=u, T=t)

# Valor final da resposta
final_value = y_out[-1]
tol = 0.01 * final_value  # 1% da resposta final

# Encontrar o tempo em que a resposta entra e permanece na faixa de ±1%
ts_graphical = 0
within_bounds = np.abs(y_out - u) <= tol
for i in range(len(within_bounds)):
    if all(within_bounds[i:]):
        ts_graphical = t_out[i]
        break

# Gerar gráfico
plt.figure(figsize=(8, 5))
plt.plot(t_out * 1e6, y_out, label='Ramp Response')
plt.plot(t_out * 1e6, u, linestyle=':', color='black', label='Step')
plt.axvline(ts_graphical * 1e6, color='green', linestyle='--', linewidth=1.2, label=f'Graphical settling time: {ts_graphical*1e6:.5f} us')
plt.xlabel('Time [us]')
plt.ylabel('Phase [rad]')
plt.title('Step Response with Settling Time (99%)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```


```{python}
#| echo: false
#| label: fig-pll-step-iasdhf-alt
#| fig-cap: "Closed-loop kjas step response of the designed PLL."
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 50e-6, 100000)

# Criar vetor da entrada (degrau de amplitude 5)
step_amplitude = omega_r * t
u = np.ones_like(t) * step_amplitude

# Simulação da resposta ao degrau via lsim
t_out, y_out, _ = signal.lsim(H_sys, U=u, T=t)
t_out, y_out2, _ = signal.lsim(O_sys, U=u, T=t)

# Gerar gráfico
plt.figure(figsize=(8, 5))
plt.plot(t_out * 1e6, y_out, label='Ramp Response')
plt.plot(t_out * 1e6, y_out2, label='Ramp N Response')
plt.plot(t_out * 1e6, u, linestyle=':', color='black', label='Step')
plt.xlabel('Time [us]')
plt.ylabel('Phase [rad]')
plt.title('Step Response with Settling Time (99%)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```









```{python}
#| echo: false
#| label: fig-pll-step-response-alt-double-ramp
#| fig-cap: "Closed-loop phase step response of the designed PLL."
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 50e-6, 100000)

# Frequências
f_base = omega_r  # 10 MHz
f_step = step_m_ang_meas  # step de 10 MHz
t_step = 20e-6  # instante do step

# Entrada em fase: integral da frequência
phi_in = np.where(
    t < t_step,
    f_base * t,
    f_base * t + f_step * (t - t_step)
)

# Simulação da resposta
t_out, y_out, _ = signal.lsim(H_sys, U=phi_in, T=t)

### --- 1º Settling Time (antes do step) ---
# Índices até o step
idx_step = np.searchsorted(t_out, t_step)
y_before = y_out[:idx_step]
u_before = phi_in[:idx_step]

# Valor final antes do step
final_val_1 = y_before[-1]
tol_1 = 0.01 * final_val_1

# Encontrar settling time 1
settling_instant1 = 0
within_1 = np.abs(y_before - u_before) <= tol_1
for i in range(len(within_1)):
    if all(within_1[i:]):
        settling_instant1 = t_out[i]
        break

### --- 2º Settling Time (após o step) ---
y_after = y_out[idx_step:]
u_after = phi_in[idx_step:]
t_after = t_out[idx_step:]

# Valor final após o step
final_val_2 = y_after[-1]
tol_2 = 0.01 * final_val_2

# Encontrar settling time 2
settling_instant2 = 0
within_2 = np.abs(y_after - u_after) <= tol_2
for i in range(len(within_2)):
    if all(within_2[i:]):
        settling_instant2 = t_after[i]
        break

settling_time1 = settling_instant1
settling_time2 = settling_instant2 - t_step

### --- Gráfico ---
plt.figure(figsize=(8, 5))
plt.plot(t_out * 1e6, y_out, label='Output Phase')
plt.plot(t_out * 1e6, phi_in, linestyle=':', color='black', label='Input Phase')

plt.axvline(settling_instant1 * 1e6, color='green', linestyle='--', linewidth=1.2, label=f'Settling time 1: {settling_time1*1e6:.2f} µs')
plt.axvline(settling_instant2 * 1e6, color='blue', linestyle='--', linewidth=1.2, label=f'Settling time 2: {settling_time2*1e6:.2f} µs')
plt.axvline(t_step * 1e6, color='purple', linestyle='--', linewidth=1.0, label='Step at 20 µs')

plt.xlabel('Time [µs]')
plt.ylabel('Phase [rad]')
plt.title('PLL Response with Two Settling Times')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

```


```{python}
#| echo: false
#| label: fig-pll-step-response-1
#| fig-cap: "Closed-loop step response of the designed PLL."
#| fig-align: center


import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 50e-6, 100000)

# Entrada: rampa em fase (step de 10 MHz em frequência)
# Fase = ∫ frequência ⇒ rampa
freq_step = omega_r  # Step de 10 MHz em frequência
phi_in = freq_step * t  # Rampa de fase

# Simulação da resposta do sistema à rampa
t_out, phi_out, _ = signal.lsim(H_sys, U=phi_in, T=t)

# Erro de seguimento
tracking_error = phi_in - phi_out

# Definir tolerância de erro (ex: 1% da entrada)
tol = 0.01 * np.max(phi_in)

# Encontrar tempo de seguimento gráfico
tracking_ts = 0
within_bounds = np.abs(tracking_error) <= tol
for i in range(len(within_bounds)):
    if all(within_bounds[i:]):
        tracking_ts = t_out[i]
        break

# Plotagem
plt.figure(figsize=(10, 6))
plt.plot(t_out * 1e6, phi_in, 'k--', label='Fase de entrada (rampa)')
plt.plot(t_out * 1e6, phi_out, 'b', label='Fase de saída')
plt.plot(t_out * 1e6, tracking_error, 'r', label='Erro de seguimento')
plt.axhline(tol, color='gray', linestyle='--', linewidth=0.8, label='±1% Tolerância')
plt.axhline(-tol, color='gray', linestyle='--', linewidth=0.8)
plt.axvline(tracking_ts * 1e6, color='green', linestyle='--', linewidth=1.2,
            label=f'Tempo de seguimento: {tracking_ts*1e6:.2f} us')
plt.title('Resposta do PLL a uma rampa de fase (step em frequência)')
plt.xlabel('Tempo [us]')
plt.ylabel('Fase [rad]')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

```











```{python}
#| echo: false
#| label: fig-phase-error-step-response
#| fig-cap: "Phase error response of step frequency."
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 30e-6, 100000)

# Criar vetor da entrada (degrau de amplitude 5)
step_amplitude = step_m_ang_meas * t
u = np.ones_like(t) * step_amplitude

# Simulação da resposta ao degrau via lsim
t_out, y_out, _ = signal.lsim(E_sys, U=u, T=t)

# Cálculo do valor máximo (pico)
max_value = np.max(np.abs(y_out))
tol = 0.01 * max_value  # 1% do valor de pico (centrado em zero)

# Novo cálculo do tempo de acomodação (settling time)
within_bounds = np.abs(y_out) <= tol
ts_graphical_peak = 0
for i in range(len(within_bounds)):
    if all(within_bounds[i:]):
        ts_graphical_peak = t_out[i]
        break

# Gerar gráfico
plt.figure(figsize=(8, 5))
plt.plot(t_out * 1e6, y_out, label='Step Response')

# Linha no valor máximo (positivo)
plt.axhline(max_value, color='blue', linestyle=':', linewidth=1.2, label=f'Max Value: {max_value:.3f}')

# Linhas horizontais em ±1% do valor de pico (em torno de zero)
plt.axhline(tol, color='purple', linestyle='--', linewidth=1.0, label=f'+1% Peak ({tol:.3e})')
plt.axhline(-tol, color='purple', linestyle='--', linewidth=1.0, label=f'-1% Peak ({-tol:.3e})')

# Marcação do novo tempo de acomodação
plt.axvline(ts_graphical_peak * 1e6, color='green', linestyle='--', linewidth=1.2, label=f'Settling Time (±1% Peak): {ts_graphical_peak*1e6:.3f} μs')

plt.xlabel('Time [us]')
plt.ylabel('Phase Error [rad]')
plt.title('Step Response with Settling Time (±1% of Peak)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()


```

```{python}
#| echo: false
#| label: fig-pll-step-response-2
#| fig-cap: "Closed-loop step response of the designed PLL."
#| fig-align: center


import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Tempo de simulação
t = np.linspace(0, 8/omega_n_meas, 100000)

# Criar vetor da entrada (degrau de amplitude 5)
step_amplitude = t
u = np.ones_like(t) * step_amplitude

# Simulação da resposta ao degrau via lsim
t_out, y_out, _ = signal.lsim(E_sys, U=u, T=t)

y_out *= omega_n_meas

# Cálculo do valor máximo (pico)
max_value = np.max(np.abs(y_out))
tol = 0

# Gerar gráfico
plt.figure(figsize=(8, 5))
plt.plot(t_out * omega_n_meas, y_out, label='Step Response')

# Linha no valor máximo (positivo)
plt.axhline(max_value, color='blue', linestyle=':', linewidth=1.2, label=f'Max Value: {max_value:.3f}')

# Linhas horizontais em ±1% do valor de pico (em torno de zero)
plt.axhline(tol, color='purple', linestyle='--', linewidth=1.0, label=f'+1% Peak ({tol:.3e})')


plt.xlabel('Time [us]')
plt.ylabel('Phase Error [rad]')
plt.title('Step Response with Settling Time (±1% of Peak)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()


```


```{python}
#| echo: false
#| label: fig-pll-step-response-3
#| fig-cap: "Closed-loop step response of the designed PLL."
#| fig-align: center


from scipy import signal
import numpy as np

# Supondo que você já tem H_sys
# H_sys = signal.TransferFunction(num, den)

# 1. Obtenha os polos do sistema
poles = H_sys.poles

# 2. Pegue o par de polos complexos conjugados dominante
#    (normalmente com parte imaginária não nula)
complex_poles = [p for p in poles if np.imag(p) != 0]
if not complex_poles:
    raise ValueError("Não há polos complexos — sistema não oscilatório ou não de 2ª ordem.")

# 3. Escolha um dos polos complexos
p = complex_poles[0]

# 4. Calcule a frequência natural (ωn) e o fator de amortecimento (ζ)
omega_n = np.abs(p)
zeta = -np.real(p) / omega_n

# 5. Imprima os resultados
#print(f"Polo dominante: {p}")
#print(f"Frequência natural ωn: {omega_n:.2e} rad/s")
print(f"Constante de amortecimento ζ: {zeta:.3f}")

```






```{python}
#| echo: false
#| label: fig-vc-step-response
#| fig-cap: "Voltage control step response of the designed PLL."
#| fig-align: center


import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import TransferFunction, step

# Tempo de simulação
t = np.linspace(0, 30e-6, 1000)

# Resposta ao degrau
t, vc_response = step(Vc_sys, T=t)
vc_response *= step_m_lin_meas

# Valor final (assumido ou estimado)
final_value = ((f_r+step_m_lin) * N - f_o) / KVCO
#final_value = 0.5
tol = 0.01 * final_value  # 1% de tolerância
upper_bound = final_value + tol
lower_bound = final_value - tol

# Encontrar settling time: busca o primeiro instante em que o sinal entra e permanece dentro da faixa de tolerância
within_bounds = np.logical_and(vc_response >= lower_bound, vc_response <= upper_bound)

# Janela de amostras para verificar se permanece dentro da tolerância
window_size = 50  # ~5% da simulação

ts_graphical = 0
for i in range(len(within_bounds) - window_size):
    if np.all(within_bounds[i:i + window_size]):
        ts_graphical = t[i]
        break

# Plotagem
plt.figure(figsize=(8, 4))
plt.plot(t * 1e6, vc_response, label='V_C(t)')
plt.axhline(upper_bound, color='red', linestyle='--', linewidth=0.8, label='+1% Tolerance')
plt.axhline(lower_bound, color='red', linestyle='--', linewidth=0.8, label='-1% Tolerance')

if ts_graphical is not None:
    plt.axvline(ts_graphical * 1e6, color='green', linestyle='--', linewidth=1.2,
                label=f'Settling time: {ts_graphical*1e6:.2f} µs')

plt.title('Resposta à entrada em degrau de frequência Δω (Tensão de controle V_C)')
plt.xlabel('Tempo [µs]')
plt.ylabel('V_C(t) [V]')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()


```

```{python}
#| echo: false
#| label: fig-pll-step-response-4
#| fig-cap: "Closed-loop step response of the designed PLL."
#| fig-align: center


import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import TransferFunction, step

# Tempo de simulação
t = np.linspace(0, 8/omega_n_meas, 1000)

# Resposta ao degrau
t, vc_response = step(Vc_sys, T=t)
vc_response *= Kvco / N

# Valor final (assumido ou estimado)
final_value = ((f_r+step_m_lin) * N - f_o) / KVCO
final_value *= KVCO / (step_m_lin_meas * N)
#final_value = 0.5

# Janela de amostras para verificar se permanece dentro da tolerância
window_size = 50  # ~5% da simulação

# Plotagem
plt.figure(figsize=(8, 4))
plt.plot(t * omega_n_meas, vc_response, label='V_C(t)')
plt.axhline(final_value, color='red', linestyle='--', linewidth=0.8, label='Valor desejado')


plt.title('Resposta à entrada em degrau de frequência Δω (Tensão de controle V_C)')
plt.xlabel('Tempo [µs]')
plt.ylabel('V_C(t) [V]')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()


```



























```{python}
#| echo: false
#| label: fig-pll-step-response-5
#| fig-cap: "Closed-loop step response of the designed PLL."
#| fig-align: center


import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Gerar a resposta em frequência
w, mag, phase = signal.bode(H_sys)

# Encontrar o ponto onde a magnitude cruza -3 dB
cutoff_index = np.argmax(mag <= -3)
cutoff_freq_ang = w[cutoff_index]
cutoff_freq_lin = cutoff_freq_ang/2/np.pi
cutoff_mag = mag[cutoff_index]

# Plotando o diagrama de Bode
plt.figure(figsize=(10, 6))

# Magnitude
plt.subplot(2, 1, 1)
plt.semilogx(w, mag, label='Magnitude (dB)')
plt.axvline(x=cutoff_freq_ang, color='r', linestyle='--', label='Cutoff Frequency (-3 dB)')
plt.axhline(y=-3, color='gray', linestyle=':', label='-3 dB')
plt.scatter(cutoff_freq_ang, cutoff_mag, color='red')  # Marcar o ponto

# Adiciona o valor da frequência no gráfico
plt.text(cutoff_freq_ang, cutoff_mag - 5, f'{format_graph(cutoff_freq_lin)}Hz', color='red',
         ha='center', va='top', fontsize=9, bbox=dict(facecolor='white', edgecolor='red', boxstyle='round'))

plt.title('Frequency Response - Bode Plot')
plt.ylabel('Magnitude (dB)')
plt.grid(True, which="both", ls="--")
plt.legend()

# Fase
plt.subplot(2, 1, 2)
plt.semilogx(w, phase)
plt.axvline(x=cutoff_freq_ang, color='r', linestyle='--')
plt.ylabel('Phase (degrees)')
plt.xlabel('Frequency (rad/s)')
plt.grid(True, which="both", ls="--")

plt.tight_layout()
plt.show()
```




```{python}
#| echo: false
#| label: fig-pll-step-response-6
#| fig-cap: "Closed-loop step response of the designed PLL."
#| fig-align: center


import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Gerar a resposta em frequência
w, mag, phase = signal.bode(F_sys)

# Encontrar o ponto onde a magnitude cruza -3 dB
cutoff_index = np.argmax(mag <= -3)
cutoff_freq_ang = w[cutoff_index]
cutoff_freq_lin = cutoff_freq_ang/2/np.pi
cutoff_mag = mag[cutoff_index]

# Plotando o diagrama de Bode
plt.figure(figsize=(10, 6))

# Magnitude
plt.subplot(2, 1, 1)
plt.semilogx(w, mag, label='Magnitude (dB)')

plt.title('Bode Plot - Loop filter')
plt.ylabel('Magnitude (dB)')
plt.grid(True, which="both", ls="--")
plt.legend()

# Fase
plt.subplot(2, 1, 2)
plt.semilogx(w, phase)
plt.ylabel('Phase (degrees)')
plt.xlabel('Frequency (rad/s)')
plt.grid(True, which="both", ls="--")

plt.tight_layout()
plt.show()
```



# Behavioral Simulation

# Conclusion

This report provides a theoretical analysis of a second-order PFD/CP-based Integer-N PLL. The maximum tolerable frequency step for which the linear model remains valid was derived, and the corresponding settling time was estimated. These results serve as a foundation for further simulation and validation studies.

# References {-}
